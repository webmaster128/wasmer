<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module contains the bulk of the interesting code performing the translation between WebAssembly bytecode and Cranelift IR."><title>wasmer_compiler_cranelift::translator::code_translator - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="wasmer_compiler_cranelift" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0 (90c541806 2023-05-31)" data-search-js="search-e077946657036a58.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-7bfb4c59cc6bc502.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../../static.files/main-f61008743c98d196.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../wasmer_compiler_cranelift/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../wasmer_compiler_cranelift/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Module code_translator</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">wasmer_compiler_cranelift</a>::<wbr><a href="../index.html">translator</a>::<wbr><a class="mod" href="#">code_translator</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/wasmer_compiler_cranelift/translator/code_translator.rs.html#4-3063">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module contains the bulk of the interesting code performing the translation between
WebAssembly bytecode and Cranelift IR.</p>
<p>The translation is done in one pass, opcode by opcode. Two main data structures are used during
code translations: the value stack and the control stack. The value stack mimics the execution
of the WebAssembly stack machine: each instruction result is pushed onto the stack and
instruction arguments are popped off the stack. Similarly, when encountering a control flow
block, it is pushed onto the control stack and popped off when encountering the corresponding
<code>End</code>.</p>
<p>Another data structure, the translation state, records information concerning unreachable code
status and about if inserting a return at the end of the function is necessary.</p>
<p>Some of the WebAssembly instructions need information about the environment for which they
are being translated:</p>
<ul>
<li>the loads and stores need the memory base address;</li>
<li>the <code>get_global</code> and <code>set_global</code> instructions depend on how the globals are implemented;</li>
<li><code>memory.size</code> and <code>memory.grow</code> are runtime functions;</li>
<li><code>call_indirect</code> has to translate the function index into the address of where this
is;</li>
</ul>
<p>That is why <code>translate_function_body</code> takes an object having the <code>WasmRuntime</code> trait as
argument.</p>
<p>There is extra complexity associated with translation of 128-bit SIMD instructions.
Wasm only considers there to be a single 128-bit vector type.  But CLIF’s type system
distinguishes different lane configurations, so considers 8X16, 16X8, 32X4 and 64X2 to be
different types.  The result is that, in wasm, it’s perfectly OK to take the output of (eg)
an <code>add.16x8</code> and use that as an operand of a <code>sub.32x4</code>, without using any cast.  But when
translated into CLIF, that will cause a verifier error due to the apparent type mismatch.</p>
<p>This file works around that problem by liberally inserting <code>bitcast</code> instructions in many
places – mostly, before the use of vector values, either as arguments to CLIF instructions
or as block actual parameters.  These are no-op casts which nevertheless have different
input and output types, and are used (mostly) to “convert” 16X8, 32X4 and 64X2-typed vectors
to the “canonical” type, 8X16.  Hence the functions <code>optionally_bitcast_vector</code>,
<code>bitcast_arguments</code>, <code>pop*_with_bitcast</code>, <code>canonicalise_then_jump</code>,
<code>canonicalise_then_br{z,nz}</code>, <code>is_non_canonical_v128</code> and <code>canonicalise_v128_values</code>.
Note that the <code>bitcast*</code> functions are occasionally used to convert to some type other than
8X16, but the <code>canonicalise*</code> functions always convert to type 8X16.</p>
<p>Be careful when adding support for new vector instructions.  And when adding new jumps, even
if they are apparently don’t have any connection to vectors.  Never generate any kind of
(inter-block) jump directly.  Instead use <code>canonicalise_then_jump</code> and
<code>canonicalise_then_br{z,nz}</code>.</p>
<p>The use of bitcasts is ugly and inefficient, but currently unavoidable:</p>
<ul>
<li>
<p>they make the logic in this file fragile: miss out a bitcast for any reason, and there is
the risk of the system failing in the verifier.  At least for debug builds.</p>
</li>
<li>
<p>in the new backends, they potentially interfere with pattern matching on CLIF – the
patterns need to take into account the presence of bitcast nodes.</p>
</li>
<li>
<p>in the new backends, they get translated into machine-level vector-register-copy
instructions, none of which are actually necessary.  We then depend on the register
allocator to coalesce them all out.</p>
</li>
<li>
<p>they increase the total number of CLIF nodes that have to be processed, hence slowing down
the compilation pipeline.  Also, the extra coalescing work generates a slowdown.</p>
</li>
</ul>
<p>A better solution which would avoid all four problems would be to remove the 8X16, 16X8,
32X4 and 64X2 types from CLIF and instead have a single V128 type.</p>
<p>For further background see also:
<a href="https://github.com/bytecodealliance/wasmtime/issues/1147">https://github.com/bytecodealliance/wasmtime/issues/1147</a>
(“Too many raw_bitcasts in SIMD code”)
<a href="https://github.com/bytecodealliance/cranelift/pull/1251">https://github.com/bytecodealliance/cranelift/pull/1251</a>
(“Add X128 type to represent WebAssembly’s V128 type”)
<a href="https://github.com/bytecodealliance/cranelift/pull/1236">https://github.com/bytecodealliance/cranelift/pull/1236</a>
(“Relax verification to allow I8X16 to act as a default vector type”)</p>
</div></details><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.bitcast_arguments.html" title="fn wasmer_compiler_cranelift::translator::code_translator::bitcast_arguments">bitcast_arguments</a></div><div class="desc docblock-short">A helper for bitcasting a sequence of values (e.g. function arguments). If a value is a
vector type that does not match its expected type, this will modify the value in place to point
to the result of a <code>raw_bitcast</code>. This conversion is necessary to translate Wasm code that
uses <code>V128</code> as function parameters (or implicitly in block parameters) and still use specific
CLIF types (e.g. <code>I32X4</code>) in the function body.</div></li><li><div class="item-name"><a class="fn" href="fn.canonicalise_then_brnz.html" title="fn wasmer_compiler_cranelift::translator::code_translator::canonicalise_then_brnz">canonicalise_then_brnz</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">The same but for a <code>brnz</code> instruction.</div></li><li><div class="item-name"><a class="fn" href="fn.canonicalise_then_brz.html" title="fn wasmer_compiler_cranelift::translator::code_translator::canonicalise_then_brz">canonicalise_then_brz</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">The same but for a <code>brz</code> instruction.</div></li><li><div class="item-name"><a class="fn" href="fn.canonicalise_then_jump.html" title="fn wasmer_compiler_cranelift::translator::code_translator::canonicalise_then_jump">canonicalise_then_jump</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Generate a <code>jump</code> instruction, but first cast all 128-bit vector values to I8X16 if they
don’t have that type.  This is done in somewhat roundabout way so as to ensure that we
almost never have to do any heap allocation.</div></li><li><div class="item-name"><a class="fn" href="fn.canonicalise_v128_values.html" title="fn wasmer_compiler_cranelift::translator::code_translator::canonicalise_v128_values">canonicalise_v128_values</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Cast to I8X16, any vector values in <code>values</code> that are of “non-canonical” type (meaning, not
I8X16), and return them in a slice.  A pre-scan is made to determine whether any casts are
actually necessary, and if not, the original slice is returned.  Otherwise the cast values
are returned in a slice that belongs to the caller-supplied <code>SmallVec</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.finalise_atomic_mem_addr.html" title="fn wasmer_compiler_cranelift::translator::code_translator::finalise_atomic_mem_addr">finalise_atomic_mem_addr</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.fold_atomic_mem_addr.html" title="fn wasmer_compiler_cranelift::translator::code_translator::fold_atomic_mem_addr">fold_atomic_mem_addr</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.get_heap_addr.html" title="fn wasmer_compiler_cranelift::translator::code_translator::get_heap_addr">get_heap_addr</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Get the address+offset to use for a heap access.</div></li><li><div class="item-name"><a class="fn" href="fn.is_non_canonical_v128.html" title="fn wasmer_compiler_cranelift::translator::code_translator::is_non_canonical_v128">is_non_canonical_v128</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.mem_op_size.html" title="fn wasmer_compiler_cranelift::translator::code_translator::mem_op_size">mem_op_size</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.optionally_bitcast_vector.html" title="fn wasmer_compiler_cranelift::translator::code_translator::optionally_bitcast_vector">optionally_bitcast_vector</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Some SIMD operations only operate on I8X16 in CLIF; this will convert them to that type by
adding a raw_bitcast if necessary.</div></li><li><div class="item-name"><a class="fn" href="fn.pop1_with_bitcast.html" title="fn wasmer_compiler_cranelift::translator::code_translator::pop1_with_bitcast">pop1_with_bitcast</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">A helper for popping and bitcasting a single value; since SIMD values can lose their type by
using v128 (i.e. CLIF’s I8x16) we must re-type the values using a bitcast to avoid CLIF
typing issues.</div></li><li><div class="item-name"><a class="fn" href="fn.pop2_with_bitcast.html" title="fn wasmer_compiler_cranelift::translator::code_translator::pop2_with_bitcast">pop2_with_bitcast</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">A helper for popping and bitcasting two values; since SIMD values can lose their type by
using v128 (i.e. CLIF’s I8x16) we must re-type the values using a bitcast to avoid CLIF
typing issues.</div></li><li><div class="item-name"><a class="fn" href="fn.prepare_load.html" title="fn wasmer_compiler_cranelift::translator::code_translator::prepare_load">prepare_load</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Prepare for a load; factors out common functionality between load and load_extend operations.</div></li><li><div class="item-name"><a class="fn" href="fn.translate_atomic_cas.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_atomic_cas">translate_atomic_cas</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_atomic_load.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_atomic_load">translate_atomic_load</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_atomic_rmw.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_atomic_rmw">translate_atomic_rmw</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_atomic_store.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_atomic_store">translate_atomic_store</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_br_if.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_br_if">translate_br_if</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_br_if_args.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_br_if_args">translate_br_if_args</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_fcmp.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_fcmp">translate_fcmp</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_icmp.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_icmp">translate_icmp</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_load.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_load">translate_load</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Translate a load instruction.</div></li><li><div class="item-name"><a class="fn" href="fn.translate_operator.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_operator">translate_operator</a></div><div class="desc docblock-short">Translates wasm operators into Cranelift IR instructions. Returns <code>true</code> if it inserted
a return.</div></li><li><div class="item-name"><a class="fn" href="fn.translate_store.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_store">translate_store</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Translate a store instruction.</div></li><li><div class="item-name"><a class="fn" href="fn.translate_unreachable_operator.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_unreachable_operator">translate_unreachable_operator</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Deals with a Wasm instruction located in an unreachable portion of the code. Most of them
are dropped but special ones like <code>End</code> or <code>Else</code> signal the potential end of the unreachable
portion so the translation state must be updated accordingly.</div></li><li><div class="item-name"><a class="fn" href="fn.translate_vector_fcmp.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_vector_fcmp">translate_vector_fcmp</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_vector_icmp.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_vector_icmp">translate_vector_icmp</a><span title="Restricted Visibility">&nbsp;🔒</span> </div></li><li><div class="item-name"><a class="fn" href="fn.type_of.html" title="fn wasmer_compiler_cranelift::translator::code_translator::type_of">type_of</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short">Determine the returned value type of a WebAssembly operator</div></li><li><div class="item-name"><a class="fn" href="fn.wasm_param_types.html" title="fn wasmer_compiler_cranelift::translator::code_translator::wasm_param_types">wasm_param_types</a></div><div class="desc docblock-short">A helper to extract all the <code>Type</code> listings of each variable in <code>params</code>
for only parameters the return true for <code>is_wasm</code>, typically paired with
<code>is_wasm_return</code> or <code>is_wasm_parameter</code>.</div></li></ul></section></div></main></body></html>