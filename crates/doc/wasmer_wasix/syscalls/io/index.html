<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Traits, helpers, and type definitions for core I/O functionality."><title>wasmer_wasix::syscalls::io - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="wasmer_wasix" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0 (90c541806 2023-05-31)" data-search-js="search-e077946657036a58.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-7bfb4c59cc6bc502.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../../../static.files/main-f61008743c98d196.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="icon" href="https://wasmer.io/images/icons/favicon-32x32.png"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../wasmer_wasix/index.html"><img src="https://github.com/wasmerio.png?size=200" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../wasmer_wasix/index.html"><img src="https://github.com/wasmerio.png?size=200" alt="logo"></a><h2 class="location"><a href="#">Module io</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">wasmer_wasix</a>::<wbr><a href="../index.html">syscalls</a>::<wbr><a class="mod" href="#">io</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.70.0/src/std/lib.rs.html#530">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Traits, helpers, and type definitions for core I/O functionality.</p>
<p>The <code>std::io</code> module contains a number of common things you’ll need
when doing input and output. The most core part of this module is
the <a href="../trait.Read.html" title="trait wasmer_wasix::syscalls::Read"><code>Read</code></a> and <a href="../trait.Write.html" title="trait wasmer_wasix::syscalls::Write"><code>Write</code></a> traits, which provide the
most general interface for reading and writing input and output.</p>
<h2 id="read-and-write"><a href="#read-and-write">Read and Write</a></h2>
<p>Because they are traits, <a href="../trait.Read.html" title="trait wasmer_wasix::syscalls::Read"><code>Read</code></a> and <a href="../trait.Write.html" title="trait wasmer_wasix::syscalls::Write"><code>Write</code></a> are implemented by a number
of other types, and you can implement them for your types too. As such,
you’ll see a few different types of I/O throughout the documentation in
this module: <a href="https://doc.rust-lang.org/1.70.0/std/fs/struct.File.html" title="struct std::fs::File"><code>File</code></a>s, <a href="https://doc.rust-lang.org/1.70.0/std/net/tcp/struct.TcpStream.html" title="struct std::net::tcp::TcpStream"><code>TcpStream</code></a>s, and sometimes even <a href="https://doc.rust-lang.org/1.70.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>Vec&lt;T&gt;</code></a>s. For
example, <a href="../trait.Read.html" title="trait wasmer_wasix::syscalls::Read"><code>Read</code></a> adds a <a href="../trait.Read.html#tymethod.read" title="method wasmer_wasix::syscalls::Read::read"><code>read</code></a> method, which we can use on
<a href="https://doc.rust-lang.org/1.70.0/std/fs/struct.File.html" title="struct std::fs::File"><code>File</code></a>s:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>std::fs::File;

<span class="kw">fn </span>main() -&gt; io::Result&lt;()&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>f = File::open(<span class="string">&quot;foo.txt&quot;</span>)<span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>buffer = [<span class="number">0</span>; <span class="number">10</span>];

    <span class="comment">// read up to 10 bytes
    </span><span class="kw">let </span>n = f.read(<span class="kw-2">&amp;mut </span>buffer)<span class="question-mark">?</span>;

    <span class="macro">println!</span>(<span class="string">&quot;The bytes: {:?}&quot;</span>, <span class="kw-2">&amp;</span>buffer[..n]);
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p><a href="../trait.Read.html" title="trait wasmer_wasix::syscalls::Read"><code>Read</code></a> and <a href="../trait.Write.html" title="trait wasmer_wasix::syscalls::Write"><code>Write</code></a> are so important, implementors of the two traits have a
nickname: readers and writers. So you’ll sometimes see ‘a reader’ instead
of ‘a type that implements the <a href="../trait.Read.html" title="trait wasmer_wasix::syscalls::Read"><code>Read</code></a> trait’. Much easier!</p>
<h3 id="seek-and-bufread"><a href="#seek-and-bufread">Seek and BufRead</a></h3>
<p>Beyond that, there are two important traits that are provided: <a href="../trait.Seek.html" title="trait wasmer_wasix::syscalls::Seek"><code>Seek</code></a>
and <a href="trait.BufRead.html" title="trait wasmer_wasix::syscalls::io::BufRead"><code>BufRead</code></a>. Both of these build on top of a reader to control
how the reading happens. <a href="../trait.Seek.html" title="trait wasmer_wasix::syscalls::Seek"><code>Seek</code></a> lets you control where the next byte is
coming from:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>std::io::SeekFrom;
<span class="kw">use </span>std::fs::File;

<span class="kw">fn </span>main() -&gt; io::Result&lt;()&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>f = File::open(<span class="string">&quot;foo.txt&quot;</span>)<span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>buffer = [<span class="number">0</span>; <span class="number">10</span>];

    <span class="comment">// skip to the last 10 bytes of the file
    </span>f.seek(SeekFrom::End(-<span class="number">10</span>))<span class="question-mark">?</span>;

    <span class="comment">// read up to 10 bytes
    </span><span class="kw">let </span>n = f.read(<span class="kw-2">&amp;mut </span>buffer)<span class="question-mark">?</span>;

    <span class="macro">println!</span>(<span class="string">&quot;The bytes: {:?}&quot;</span>, <span class="kw-2">&amp;</span>buffer[..n]);
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p><a href="trait.BufRead.html" title="trait wasmer_wasix::syscalls::io::BufRead"><code>BufRead</code></a> uses an internal buffer to provide a number of other ways to read, but
to show it off, we’ll need to talk about buffers in general. Keep reading!</p>
<h3 id="bufreader-and-bufwriter"><a href="#bufreader-and-bufwriter">BufReader and BufWriter</a></h3>
<p>Byte-based interfaces are unwieldy and can be inefficient, as we’d need to be
making near-constant calls to the operating system. To help with this,
<code>std::io</code> comes with two structs, <a href="struct.BufReader.html" title="struct wasmer_wasix::syscalls::io::BufReader"><code>BufReader</code></a> and <a href="struct.BufWriter.html" title="struct wasmer_wasix::syscalls::io::BufWriter"><code>BufWriter</code></a>, which wrap
readers and writers. The wrapper uses a buffer, reducing the number of
calls and providing nicer methods for accessing exactly what you want.</p>
<p>For example, <a href="struct.BufReader.html" title="struct wasmer_wasix::syscalls::io::BufReader"><code>BufReader</code></a> works with the <a href="trait.BufRead.html" title="trait wasmer_wasix::syscalls::io::BufRead"><code>BufRead</code></a> trait to add extra
methods to any reader:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>std::io::BufReader;
<span class="kw">use </span>std::fs::File;

<span class="kw">fn </span>main() -&gt; io::Result&lt;()&gt; {
    <span class="kw">let </span>f = File::open(<span class="string">&quot;foo.txt&quot;</span>)<span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>reader = BufReader::new(f);
    <span class="kw">let </span><span class="kw-2">mut </span>buffer = String::new();

    <span class="comment">// read a line into buffer
    </span>reader.read_line(<span class="kw-2">&amp;mut </span>buffer)<span class="question-mark">?</span>;

    <span class="macro">println!</span>(<span class="string">&quot;{buffer}&quot;</span>);
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p><a href="struct.BufWriter.html" title="struct wasmer_wasix::syscalls::io::BufWriter"><code>BufWriter</code></a> doesn’t add any new ways of writing; it just buffers every call
to <a href="../trait.Write.html#tymethod.write" title="method wasmer_wasix::syscalls::Write::write"><code>write</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>std::io::BufWriter;
<span class="kw">use </span>std::fs::File;

<span class="kw">fn </span>main() -&gt; io::Result&lt;()&gt; {
    <span class="kw">let </span>f = File::create(<span class="string">&quot;foo.txt&quot;</span>)<span class="question-mark">?</span>;
    {
        <span class="kw">let </span><span class="kw-2">mut </span>writer = BufWriter::new(f);

        <span class="comment">// write a byte to the buffer
        </span>writer.write(<span class="kw-2">&amp;</span>[<span class="number">42</span>])<span class="question-mark">?</span>;

    } <span class="comment">// the buffer is flushed once writer goes out of scope

    </span><span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h3 id="standard-input-and-output"><a href="#standard-input-and-output">Standard input and output</a></h3>
<p>A very common source of input is standard input:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io;

<span class="kw">fn </span>main() -&gt; io::Result&lt;()&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>input = String::new();

    io::stdin().read_line(<span class="kw-2">&amp;mut </span>input)<span class="question-mark">?</span>;

    <span class="macro">println!</span>(<span class="string">&quot;You typed: {}&quot;</span>, input.trim());
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>Note that you cannot use the <a href="../../book/appendix-02-operators.html"><code>?</code> operator</a> in functions that do not return
a <a href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a>. Instead, you can call <a href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html#method.unwrap" title="method core::result::Result::unwrap"><code>.unwrap()</code></a>
or <code>match</code> on the return value to catch any possible errors:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io;

<span class="kw">let </span><span class="kw-2">mut </span>input = String::new();

io::stdin().read_line(<span class="kw-2">&amp;mut </span>input).unwrap();</code></pre></div>
<p>And a very common source of output is standard output:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() -&gt; io::Result&lt;()&gt; {
    io::stdout().write(<span class="kw-2">&amp;</span>[<span class="number">42</span>])<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>Of course, using <a href="fn.stdout.html" title="fn wasmer_wasix::syscalls::io::stdout"><code>io::stdout</code></a> directly is less common than something like
<a href="https://doc.rust-lang.org/1.70.0/std/macro.println.html" title="macro std::println"><code>println!</code></a>.</p>
<h3 id="iterator-types"><a href="#iterator-types">Iterator types</a></h3>
<p>A large number of the structures provided by <code>std::io</code> are for various
ways of iterating over I/O. For example, <a href="struct.Lines.html" title="struct wasmer_wasix::syscalls::io::Lines"><code>Lines</code></a> is used to split over
lines:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io;
<span class="kw">use </span>std::io::prelude::<span class="kw-2">*</span>;
<span class="kw">use </span>std::io::BufReader;
<span class="kw">use </span>std::fs::File;

<span class="kw">fn </span>main() -&gt; io::Result&lt;()&gt; {
    <span class="kw">let </span>f = File::open(<span class="string">&quot;foo.txt&quot;</span>)<span class="question-mark">?</span>;
    <span class="kw">let </span>reader = BufReader::new(f);

    <span class="kw">for </span>line <span class="kw">in </span>reader.lines() {
        <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, line<span class="question-mark">?</span>);
    }
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h3 id="functions"><a href="#functions">Functions</a></h3>
<p>There are a number of <a href="#functions-1">functions</a> that offer access to various
features. For example, we can use three of these functions to copy everything
from standard input to standard output:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io;

<span class="kw">fn </span>main() -&gt; io::Result&lt;()&gt; {
    io::copy(<span class="kw-2">&amp;mut </span>io::stdin(), <span class="kw-2">&amp;mut </span>io::stdout())<span class="question-mark">?</span>;
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h3 id="ioresult"><a href="#ioresult">io::Result</a></h3>
<p>Last, but certainly not least, is <a href="type.Result.html" title="type wasmer_wasix::syscalls::io::Result"><code>io::Result</code></a>. This type is used
as the return type of many <code>std::io</code> functions that can cause an error, and
can be returned from your own functions as well. Many of the examples in this
module use the <a href="../../book/appendix-02-operators.html"><code>?</code> operator</a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::io;

<span class="kw">fn </span>read_input() -&gt; io::Result&lt;()&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>input = String::new();

    io::stdin().read_line(<span class="kw-2">&amp;mut </span>input)<span class="question-mark">?</span>;

    <span class="macro">println!</span>(<span class="string">&quot;You typed: {}&quot;</span>, input.trim());

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>The return type of <code>read_input()</code>, <a href="type.Result.html" title="type wasmer_wasix::syscalls::io::Result"><code>io::Result&lt;()&gt;</code></a>, is a very
common type for functions which don’t have a ‘real’ return value, but do want to
return errors if they happen. In this case, the only purpose of this function is
to read the line and print it, so we use <code>()</code>.</p>
<h3 id="platform-specific-behavior"><a href="#platform-specific-behavior">Platform-specific behavior</a></h3>
<p>Many I/O functions throughout the standard library are documented to indicate
what various library or syscalls they are delegated to. This is done to help
applications both understand what’s happening under the hood as well as investigate
any possibly unclear semantics. Note, however, that this is informative, not a binding
contract. The implementation of many of these functions are subject to change over
time and may call fewer or more syscalls/library functions.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod wasmer_wasix::syscalls::io::prelude">prelude</a></div><div class="desc docblock-short">The I/O Prelude.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.BorrowedBuf.html" title="struct wasmer_wasix::syscalls::io::BorrowedBuf">BorrowedBuf</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">A borrowed byte buffer which is incrementally filled and initialized.</div></li><li><div class="item-name"><a class="struct" href="struct.BorrowedCursor.html" title="struct wasmer_wasix::syscalls::io::BorrowedCursor">BorrowedCursor</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">A writeable view of the unfilled portion of a <a href="struct.BorrowedBuf.html" title="struct wasmer_wasix::syscalls::io::BorrowedBuf"><code>BorrowedBuf</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.BufReader.html" title="struct wasmer_wasix::syscalls::io::BufReader">BufReader</a></div><div class="desc docblock-short">The <code>BufReader&lt;R&gt;</code> struct adds buffering to any reader.</div></li><li><div class="item-name"><a class="struct" href="struct.BufWriter.html" title="struct wasmer_wasix::syscalls::io::BufWriter">BufWriter</a></div><div class="desc docblock-short">Wraps a writer and buffers its output.</div></li><li><div class="item-name"><a class="struct" href="struct.Bytes.html" title="struct wasmer_wasix::syscalls::io::Bytes">Bytes</a></div><div class="desc docblock-short">An iterator over <code>u8</code> values of a reader.</div></li><li><div class="item-name"><a class="struct" href="struct.Chain.html" title="struct wasmer_wasix::syscalls::io::Chain">Chain</a></div><div class="desc docblock-short">Adapter to chain together two readers.</div></li><li><div class="item-name"><a class="struct" href="struct.Cursor.html" title="struct wasmer_wasix::syscalls::io::Cursor">Cursor</a></div><div class="desc docblock-short">A <code>Cursor</code> wraps an in-memory buffer and provides it with a
<a href="../trait.Seek.html" title="trait wasmer_wasix::syscalls::Seek"><code>Seek</code></a> implementation.</div></li><li><div class="item-name"><a class="struct" href="struct.Empty.html" title="struct wasmer_wasix::syscalls::io::Empty">Empty</a></div><div class="desc docblock-short">A reader which is always at EOF.</div></li><li><div class="item-name"><a class="struct" href="struct.Error.html" title="struct wasmer_wasix::syscalls::io::Error">Error</a></div><div class="desc docblock-short">The error type for I/O operations of the <a href="../trait.Read.html" title="trait wasmer_wasix::syscalls::Read"><code>Read</code></a>, <a href="../trait.Write.html" title="trait wasmer_wasix::syscalls::Write"><code>Write</code></a>, <a href="../trait.Seek.html" title="trait wasmer_wasix::syscalls::Seek"><code>Seek</code></a>, and
associated traits.</div></li><li><div class="item-name"><a class="struct" href="struct.IntoInnerError.html" title="struct wasmer_wasix::syscalls::io::IntoInnerError">IntoInnerError</a></div><div class="desc docblock-short">An error returned by <a href="struct.BufWriter.html#method.into_inner" title="method wasmer_wasix::syscalls::io::BufWriter::into_inner"><code>BufWriter::into_inner</code></a> which combines an error that
happened while writing out the buffer, and the buffered writer object
which may be used to recover from the condition.</div></li><li><div class="item-name"><a class="struct" href="struct.IoSlice.html" title="struct wasmer_wasix::syscalls::io::IoSlice">IoSlice</a></div><div class="desc docblock-short">A buffer type used with <code>Write::write_vectored</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.IoSliceMut.html" title="struct wasmer_wasix::syscalls::io::IoSliceMut">IoSliceMut</a></div><div class="desc docblock-short">A buffer type used with <code>Read::read_vectored</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.LineWriter.html" title="struct wasmer_wasix::syscalls::io::LineWriter">LineWriter</a></div><div class="desc docblock-short">Wraps a writer and buffers output to it, flushing whenever a newline
(<code>0x0a</code>, <code>'\n'</code>) is detected.</div></li><li><div class="item-name"><a class="struct" href="struct.Lines.html" title="struct wasmer_wasix::syscalls::io::Lines">Lines</a></div><div class="desc docblock-short">An iterator over the lines of an instance of <code>BufRead</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Repeat.html" title="struct wasmer_wasix::syscalls::io::Repeat">Repeat</a></div><div class="desc docblock-short">A reader which yields one byte over and over and over and over and over and…</div></li><li><div class="item-name"><a class="struct" href="struct.Sink.html" title="struct wasmer_wasix::syscalls::io::Sink">Sink</a></div><div class="desc docblock-short">A writer which will move data into the void.</div></li><li><div class="item-name"><a class="struct" href="struct.Split.html" title="struct wasmer_wasix::syscalls::io::Split">Split</a></div><div class="desc docblock-short">An iterator over the contents of an instance of <code>BufRead</code> split on a
particular byte.</div></li><li><div class="item-name"><a class="struct" href="struct.Stderr.html" title="struct wasmer_wasix::syscalls::io::Stderr">Stderr</a></div><div class="desc docblock-short">A handle to the standard error stream of a process.</div></li><li><div class="item-name"><a class="struct" href="struct.StderrLock.html" title="struct wasmer_wasix::syscalls::io::StderrLock">StderrLock</a></div><div class="desc docblock-short">A locked reference to the <a href="struct.Stderr.html" title="struct wasmer_wasix::syscalls::io::Stderr"><code>Stderr</code></a> handle.</div></li><li><div class="item-name"><a class="struct" href="struct.Stdin.html" title="struct wasmer_wasix::syscalls::io::Stdin">Stdin</a></div><div class="desc docblock-short">A handle to the standard input stream of a process.</div></li><li><div class="item-name"><a class="struct" href="struct.StdinLock.html" title="struct wasmer_wasix::syscalls::io::StdinLock">StdinLock</a></div><div class="desc docblock-short">A locked reference to the <a href="struct.Stdin.html" title="struct wasmer_wasix::syscalls::io::Stdin"><code>Stdin</code></a> handle.</div></li><li><div class="item-name"><a class="struct" href="struct.Stdout.html" title="struct wasmer_wasix::syscalls::io::Stdout">Stdout</a></div><div class="desc docblock-short">A handle to the global standard output stream of the current process.</div></li><li><div class="item-name"><a class="struct" href="struct.StdoutLock.html" title="struct wasmer_wasix::syscalls::io::StdoutLock">StdoutLock</a></div><div class="desc docblock-short">A locked reference to the <a href="struct.Stdout.html" title="struct wasmer_wasix::syscalls::io::Stdout"><code>Stdout</code></a> handle.</div></li><li><div class="item-name"><a class="struct" href="struct.Take.html" title="struct wasmer_wasix::syscalls::io::Take">Take</a></div><div class="desc docblock-short">Reader adapter which limits the bytes read from an underlying reader.</div></li><li><div class="item-name"><a class="struct" href="struct.WriterPanicked.html" title="struct wasmer_wasix::syscalls::io::WriterPanicked">WriterPanicked</a></div><div class="desc docblock-short">Error returned for the buffered data from <code>BufWriter::into_parts</code>, when the underlying
writer has previously panicked.  Contains the (possibly partly written) buffered data.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.ErrorKind.html" title="enum wasmer_wasix::syscalls::io::ErrorKind">ErrorKind</a></div><div class="desc docblock-short">A list specifying general categories of I/O error.</div></li><li><div class="item-name"><a class="enum" href="enum.SeekFrom.html" title="enum wasmer_wasix::syscalls::io::SeekFrom">SeekFrom</a></div><div class="desc docblock-short">Enumeration of possible methods to seek within an I/O object.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.BufRead.html" title="trait wasmer_wasix::syscalls::io::BufRead">BufRead</a></div><div class="desc docblock-short">A <code>BufRead</code> is a type of <code>Read</code>er which has an internal buffer, allowing it
to perform extra ways of reading.</div></li><li><div class="item-name"><a class="trait" href="trait.IsTerminal.html" title="trait wasmer_wasix::syscalls::io::IsTerminal">IsTerminal</a></div><div class="desc docblock-short">Trait to determine if a descriptor/handle refers to a terminal/tty.</div></li><li><div class="item-name"><a class="trait" href="trait.Read.html" title="trait wasmer_wasix::syscalls::io::Read">Read</a></div><div class="desc docblock-short">The <code>Read</code> trait allows for reading bytes from a source.</div></li><li><div class="item-name"><a class="trait" href="trait.Seek.html" title="trait wasmer_wasix::syscalls::io::Seek">Seek</a></div><div class="desc docblock-short">The <code>Seek</code> trait provides a cursor which can be moved within a stream of
bytes.</div></li><li><div class="item-name"><a class="trait" href="trait.Write.html" title="trait wasmer_wasix::syscalls::io::Write">Write</a></div><div class="desc docblock-short">A trait for objects which are byte-oriented sinks.</div></li></ul><h2 id="functions-1" class="small-section-header"><a href="#functions-1">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.copy.html" title="fn wasmer_wasix::syscalls::io::copy">copy</a></div><div class="desc docblock-short">Copies the entire contents of a reader into a writer.</div></li><li><div class="item-name"><a class="fn" href="fn.empty.html" title="fn wasmer_wasix::syscalls::io::empty">empty</a></div><div class="desc docblock-short">Constructs a new handle to an empty reader.</div></li><li><div class="item-name"><a class="fn" href="fn.read_to_string.html" title="fn wasmer_wasix::syscalls::io::read_to_string">read_to_string</a></div><div class="desc docblock-short">Read all bytes from a <a href="../trait.Read.html" title="trait wasmer_wasix::syscalls::Read">reader</a> into a new <a href="https://doc.rust-lang.org/1.70.0/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.repeat.html" title="fn wasmer_wasix::syscalls::io::repeat">repeat</a></div><div class="desc docblock-short">Creates an instance of a reader that infinitely repeats one byte.</div></li><li><div class="item-name"><a class="fn" href="fn.sink.html" title="fn wasmer_wasix::syscalls::io::sink">sink</a></div><div class="desc docblock-short">Creates an instance of a writer which will successfully consume all data.</div></li><li><div class="item-name"><a class="fn" href="fn.stderr.html" title="fn wasmer_wasix::syscalls::io::stderr">stderr</a></div><div class="desc docblock-short">Constructs a new handle to the standard error of the current process.</div></li><li><div class="item-name"><a class="fn" href="fn.stdin.html" title="fn wasmer_wasix::syscalls::io::stdin">stdin</a></div><div class="desc docblock-short">Constructs a new handle to the standard input of the current process.</div></li><li><div class="item-name"><a class="fn" href="fn.stdout.html" title="fn wasmer_wasix::syscalls::io::stdout">stdout</a></div><div class="desc docblock-short">Constructs a new handle to the standard output of the current process.</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.RawOsError.html" title="type wasmer_wasix::syscalls::io::RawOsError">RawOsError</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">The type of raw OS error codes returned by <a href="struct.Error.html#method.raw_os_error" title="method wasmer_wasix::syscalls::io::Error::raw_os_error"><code>Error::raw_os_error</code></a>.</div></li><li><div class="item-name"><a class="type" href="type.Result.html" title="type wasmer_wasix::syscalls::io::Result">Result</a></div><div class="desc docblock-short">A specialized <a href="https://doc.rust-lang.org/1.70.0/core/result/enum.Result.html" title="enum core::result::Result"><code>Result</code></a> type for I/O operations.</div></li></ul></section></div></main></body></html>